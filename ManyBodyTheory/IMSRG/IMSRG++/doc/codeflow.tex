%%%%% add these to the refman.tex 
%%\usepackage{listings}
%%\lstset{language=[90]Fortran,
%%        basicstyle=\ttfamily,
%%        keywordstyle=\color{red},
%%        commentstyle=\color{green},
%%        morecomment=[l]{!\ }% Comment only with space after !
%%}
%%%%% 
%% \chapter{Code Structure/Flow}
%% \input{codeflow}
%%%%%



Written by Y.-H. Song. 

Basic code structure and flow for rough idea. 
Because it is up to my understanding, there can be error
and will be changes according to my understanding. 

\section{Read in arguments and input files}
\begin{itemize}
 \item Default parameters, and everything passed by command line args.	
   \begin{lstlisting}[frame=single]
	2bme                          :  none
	3bme                          :  none
	LECs                          :  EM2.0_2.0
	basis                         :  HF
	core_generator                :  atan
	custom_valence_space          :  
	denominator_delta_orbit       :  none
	flowfile                      :  default
	fmt2                          :  me2j
	fmt3                          :  me3j
	goose_tank                    :  false
	intfile                       :  default
	method                        :  magnus
	nucleon_mass_correction       :  false
	occ_file                      :  none
	reference                     :  default
	scratch                       :  
	use_brueckner_bch             :  false
	valence_file_format           :  nushellx
	valence_generator             :  shell-model-atan
	valence_space                 :  
	write_omega                   :  false
	BetaCM                        :  0
	denominator_delta             :  0
	domega                        :  0.2
	ds_0                          :  0.5
	dsmax                         :  0.5
	eta_criterion                 :  1e-06
	hw                            :  20
	hwBetaCM                      :  -1
	ode_tolerance                 :  1e-06
	omega_norm_max                :  0.25
	smax                          :  200
	A                             :  -1
	e3max                         :  12
	emax                          :  6
	file2e1max                    :  12
	file2e2max                    :  24
	file2lmax                     :  10
	file3e1max                    :  12
	file3e2max                    :  24
	file3e3max                    :  12
	lmax3                         :  -1
	nsteps                        :  -1
	Operators                     :  
	OperatorsFromFile             :  
	SPWF                          :  
    \end{lstlisting}   
   \item set ReadWrite class 'rw' 
\end{itemize} 		

\section{prepare model space}
\begin{itemize}
  \item set valence space
  \item set ModelSpace class 'modelspace'
  \begin{itemize}
    \item set 'reference'
    \item initialize occ from file 
    \item set nsteps , SetHbarOmega, SetTargetMass, SetE3max,SetLmax3
  \end{itemize} 	
\end{itemize}		
\section{prepare operator}
\begin{itemize}
  \item define Operator class Hbare from modelspace and particle rank
  \item Hbare.SetHermitian() 
  \item Hbare.SetGooseTank
\end{itemize} 

\section{prepare interaction}
\begin{itemize}
  \item read two-body matrix elements in various formats 
  \begin{itemize}
    \item me2j 
    \item navratil
    \item oslo 
    \item oakridge has 'bin' or 'ascii' mode 
    \item takayuki 
    \item nushellx     
  \end{itemize}
  \item Except 'nushellx' format case, add Trel operator to Hbare.
  \item add nucleon mass correction in Trel 
  \item read Darmssdt 3-body interaction if particle rank >=3. 
  \item add a Lawson term,(betaCM term) 
\end{itemize}
\section{prepare Hartree-Fock basis}
\begin{itemize}
  \item declare HartreeFock class 'hf' from Hbare
  \item hf.solve() 
\end{itemize} 
\section{prepare Hamiltonian}
\begin{itemize}
  \item declare operator 'HNO' from Hbare 
  \item do normal ordering to HNO. 
        hf.GetNormalOrderedH() or Hbare.DoNormalOrdering() 
  \item SPWF:? set radial points, Rmax, spwf indices, PSI and so on ?
  \item add betaCM term to HNO. 
  \item estimate ground state energy by HF or MBPT3. 
\end{itemize} 
\section{calculate operators} 
This part is not clear how to understand. 
 At least, I suppose it is to define observales to be calculated.   

there are loops in 'opnames', 'opsfromfile', 'ops' and so on. 
  \begin{lstlisting}[frame=single]
   for (auto& opname : opnames)
  {
    ops.emplace_back( imsrg_util::OperatorFromString(modelspace,opname) );
  }
  \end{lstlisting}
\begin{itemize}
  \item If method is 'HF', print output and ends the code. 
  \item If method is 'FCI', print outputs in nushellx format
        such as '.int','.sp','.op' .
        But what is exactly the output here? 
\end{itemize} 

\section{IMSRG solve}
 This part semes to be the main IMSRG. 
\begin{itemize}
  \item declare IMSRGSolver class imsrgsolver(HNO) 
   \begin{lstlisting}[frame=single]
  IMSRGSolver imsrgsolver(HNO);
  imsrgsolver.SetReadWrite(rw);
  imsrgsolver.SetEtaCriterion(eta_criterion);
  bool brueckner_restart = false;
   \end{lstlisting}
 \item setup solver according to method.('NSmagnus', 'brueckner' etc.) 
      and solve.
  \begin{lstlisting}[frame=single]
  imsrgsolver.SetMethod(method);
  imsrgsolver.SetHin(HNO);
  imsrgsolver.SetSmax(smax);
  imsrgsolver.SetFlowFile(flowfile);
  imsrgsolver.SetDs(ds_0);
  imsrgsolver.SetDsmax(dsmax);
  imsrgsolver.SetDenominatorDelta(denominator_delta);
  imsrgsolver.SetdOmega(domega);
  imsrgsolver.SetOmegaNormMax(omega_norm_max);
  imsrgsolver.SetODETolerance(ode_tolerance);
  ...
  imsrgsolver.SetGenerator(core_generator);
  ... 
  imsrgsolver.Solve();
   \end{lstlisting}
 \item if method is 'magnus', increase smax 
 \item if 'brueckner restart',
       change HNO and  solve again (imsrgsolver.Solve())     
 \item I don't see no clear separation between IMSRG and VS-IMSRG.
 But, I suppose 'nsetps >1' seems to be related with VS-IMSRG. 
    
  \begin{lstlisting}[frame=single]
    if (nsteps > 1) // two-step decoupling, do core first
    {...
     imsrgsolver.SetSmax(smax);
     imsrgsolver.Solve();
    } 
  \end{lstlisting} 

 \item Transform all operators in 'magnus' method. 
\end{itemize} 
\section{VS-IMSRG solve}

\begin{itemize}
  \item re-normal order wrt the core 
  \begin{lstlisting}[frame=single]
   // If we're doing targeted/ensemble normal ordering 
   // we now re-normal order wrt to the core
   // and do any remaining flow.
   ModelSpace ms2(modelspace);
   ...
    if ( renormal_order )
  {
    HNO = imsrgsolver.GetH_s();
    ...
    HNO = HNO.UndoNormalOrdering(); 
    ms2.SetReference(ms2.core); // change the reference
    HNO.SetModelSpace(ms2);
    HNO = HNO.DoNormalOrdering();
    imsrgsolver.SetHin(HNO);
    imsrgsolver.SetEtaCriterion(1e-4);
    imsrgsolver.Solve();
    ... 
  }
  \end{lstlisting} 
  \item do similar to operators 
\end{itemize} 

\section{Write output}
\begin{itemize}
  \item write shell model interaction file 
  \item or write single reference result  
\end{itemize} 
