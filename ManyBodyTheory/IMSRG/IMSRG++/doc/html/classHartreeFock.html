<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IM-SRG++: HartreeFock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IM-SRG++
   &#160;<span id="projectnumber">0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classHartreeFock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HartreeFock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad39d695b75dc9c6aa2f0e1ff81d1adc5"><td class="memItemLeft" align="right" valign="top"><a id="ad39d695b75dc9c6aa2f0e1ff81d1adc5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ad39d695b75dc9c6aa2f0e1ff81d1adc5">HartreeFock</a> (<a class="el" href="classOperator.html">Operator</a> &amp;hbare)</td></tr>
<tr class="memdesc:ad39d695b75dc9c6aa2f0e1ff81d1adc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ad39d695b75dc9c6aa2f0e1ff81d1adc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6bac9b4403e4bc599a89ad0c9b6056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a3d6bac9b4403e4bc599a89ad0c9b6056">BuildMonopoleV</a> ()</td></tr>
<tr class="memdesc:a3d6bac9b4403e4bc599a89ad0c9b6056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only the monopole part of V is needed, so construct it.  <a href="#a3d6bac9b4403e4bc599a89ad0c9b6056">More...</a><br /></td></tr>
<tr class="separator:a3d6bac9b4403e4bc599a89ad0c9b6056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c146af25a09f427cc626d877ec6e518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a1c146af25a09f427cc626d877ec6e518">BuildMonopoleV3</a> ()</td></tr>
<tr class="memdesc:a1c146af25a09f427cc626d877ec6e518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only the monopole part of V3 is needed.  <a href="#a1c146af25a09f427cc626d877ec6e518">More...</a><br /></td></tr>
<tr class="separator:a1c146af25a09f427cc626d877ec6e518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f7b0c4cb7373a3f1a69ca27a4dfaed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a00f7b0c4cb7373a3f1a69ca27a4dfaed">Diagonalize</a> ()</td></tr>
<tr class="memdesc:a00f7b0c4cb7373a3f1a69ca27a4dfaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonalize the Fock matrix.  <a href="#a00f7b0c4cb7373a3f1a69ca27a4dfaed">More...</a><br /></td></tr>
<tr class="separator:a00f7b0c4cb7373a3f1a69ca27a4dfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fe0eb16f6e5835c920bf8fa98c4442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a84fe0eb16f6e5835c920bf8fa98c4442">UpdateF</a> ()</td></tr>
<tr class="memdesc:a84fe0eb16f6e5835c920bf8fa98c4442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Fock matrix with the new transformation coefficients C.  <a href="#a84fe0eb16f6e5835c920bf8fa98c4442">More...</a><br /></td></tr>
<tr class="separator:a84fe0eb16f6e5835c920bf8fa98c4442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad38c905e7e9f9e9757b5800e6910c61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aad38c905e7e9f9e9757b5800e6910c61">UpdateDensityMatrix</a> ()</td></tr>
<tr class="memdesc:aad38c905e7e9f9e9757b5800e6910c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the density matrix with the new coefficients C.  <a href="#aad38c905e7e9f9e9757b5800e6910c61">More...</a><br /></td></tr>
<tr class="separator:aad38c905e7e9f9e9757b5800e6910c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c842cbf4e8caec72591c1205794f1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a74c842cbf4e8caec72591c1205794f1f">FillLowestOrbits</a> ()</td></tr>
<tr class="memdesc:a74c842cbf4e8caec72591c1205794f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get new occupations based on the current single-particle energies.  <a href="#a74c842cbf4e8caec72591c1205794f1f">More...</a><br /></td></tr>
<tr class="separator:a74c842cbf4e8caec72591c1205794f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dbc7d8aa192f192f23347c46ad084c"><td class="memItemLeft" align="right" valign="top"><a id="af7dbc7d8aa192f192f23347c46ad084c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#af7dbc7d8aa192f192f23347c46ad084c">UpdateReference</a> ()</td></tr>
<tr class="memdesc:af7dbc7d8aa192f192f23347c46ad084c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we got new occupations in FillLowestOrbits, then we should update the hole states in the reference. <br /></td></tr>
<tr class="separator:af7dbc7d8aa192f192f23347c46ad084c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ab9c4f96e68b1c9acea1d1407ecc60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a35ab9c4f96e68b1c9acea1d1407ecc60">CheckConvergence</a> ()</td></tr>
<tr class="memdesc:a35ab9c4f96e68b1c9acea1d1407ecc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the current energies with those from the previous iteration.  <a href="#a35ab9c4f96e68b1c9acea1d1407ecc60">More...</a><br /></td></tr>
<tr class="separator:a35ab9c4f96e68b1c9acea1d1407ecc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0666507747c17845ab4f74b97414703c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a0666507747c17845ab4f74b97414703c">Solve</a> ()</td></tr>
<tr class="memdesc:a0666507747c17845ab4f74b97414703c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonalize and UpdateF until convergence.  <a href="#a0666507747c17845ab4f74b97414703c">More...</a><br /></td></tr>
<tr class="separator:a0666507747c17845ab4f74b97414703c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef506c5c5bc0f317ceb9c71bdc44d62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aef506c5c5bc0f317ceb9c71bdc44d62b">CalcEHF</a> ()</td></tr>
<tr class="memdesc:aef506c5c5bc0f317ceb9c71bdc44d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the Hartree Fock energy.  <a href="#aef506c5c5bc0f317ceb9c71bdc44d62b">More...</a><br /></td></tr>
<tr class="separator:aef506c5c5bc0f317ceb9c71bdc44d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3bdda2ea86f9a3b18d203c9aecc353"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a2c3bdda2ea86f9a3b18d203c9aecc353">PrintEHF</a> ()</td></tr>
<tr class="memdesc:a2c3bdda2ea86f9a3b18d203c9aecc353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the Hartree Fock energy.  <a href="#a2c3bdda2ea86f9a3b18d203c9aecc353">More...</a><br /></td></tr>
<tr class="separator:a2c3bdda2ea86f9a3b18d203c9aecc353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb6754f57250a03a2e1bd3e2aef4daf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a2eb6754f57250a03a2e1bd3e2aef4daf">ReorderCoefficients</a> ()</td></tr>
<tr class="memdesc:a2eb6754f57250a03a2e1bd3e2aef4daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder the coefficients in C to eliminate phases etc.  <a href="#a2eb6754f57250a03a2e1bd3e2aef4daf">More...</a><br /></td></tr>
<tr class="separator:a2eb6754f57250a03a2e1bd3e2aef4daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55914915cea16669e549025c244b62d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a55914915cea16669e549025c244b62d0">TransformToHFBasis</a> (<a class="el" href="classOperator.html">Operator</a> &amp;OpIn)</td></tr>
<tr class="memdesc:a55914915cea16669e549025c244b62d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an operator from oscillator basis to HF basis.  <a href="#a55914915cea16669e549025c244b62d0">More...</a><br /></td></tr>
<tr class="separator:a55914915cea16669e549025c244b62d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bdb52033e2f62bba72ea86bc196b37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a17bdb52033e2f62bba72ea86bc196b37">GetNormalOrderedH</a> ()</td></tr>
<tr class="memdesc:a17bdb52033e2f62bba72ea86bc196b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Hamiltonian in the HF basis at the normal-ordered 2body level.  <a href="#a17bdb52033e2f62bba72ea86bc196b37">More...</a><br /></td></tr>
<tr class="separator:a17bdb52033e2f62bba72ea86bc196b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7da4e35f14128c1c0becf204e15a4e1"><td class="memItemLeft" align="right" valign="top"><a id="ad7da4e35f14128c1c0becf204e15a4e1"></a>
<a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ad7da4e35f14128c1c0becf204e15a4e1">GetNormalOrderedH</a> (arma::mat &amp;Cin)</td></tr>
<tr class="memdesc:ad7da4e35f14128c1c0becf204e15a4e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Hamiltonian in the HF basis at the normal-ordered 2body level. <br /></td></tr>
<tr class="separator:ad7da4e35f14128c1c0becf204e15a4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53011b381945ed5c61f50b209db5bf64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a53011b381945ed5c61f50b209db5bf64">GetOmega</a> ()</td></tr>
<tr class="memdesc:a53011b381945ed5c61f50b209db5bf64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a generator of the Hartree Fock transformation.  <a href="#a53011b381945ed5c61f50b209db5bf64">More...</a><br /></td></tr>
<tr class="separator:a53011b381945ed5c61f50b209db5bf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2a07edc3ccaa0cf9bbc0faadfd9ddf"><td class="memItemLeft" align="right" valign="top"><a id="a7f2a07edc3ccaa0cf9bbc0faadfd9ddf"></a>
<a class="el" href="classOperator.html">Operator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetHbare</b> ()</td></tr>
<tr class="separator:a7f2a07edc3ccaa0cf9bbc0faadfd9ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96b85eca26bf7c57430242201066932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ab96b85eca26bf7c57430242201066932">PrintSPE</a> ()</td></tr>
<tr class="memdesc:ab96b85eca26bf7c57430242201066932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter function for Hbare.  <a href="#ab96b85eca26bf7c57430242201066932">More...</a><br /></td></tr>
<tr class="separator:ab96b85eca26bf7c57430242201066932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d5163a8df635593edbeaa531aa5a34"><td class="memItemLeft" align="right" valign="top"><a id="a51d5163a8df635593edbeaa531aa5a34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a51d5163a8df635593edbeaa531aa5a34">PrintSPEandWF</a> ()</td></tr>
<tr class="memdesc:a51d5163a8df635593edbeaa531aa5a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out the single-particle energies and wave functions. <br /></td></tr>
<tr class="separator:a51d5163a8df635593edbeaa531aa5a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3c1b45c5418ead19f258774a301f83"><td class="memItemLeft" align="right" valign="top"><a id="aef3c1b45c5418ead19f258774a301f83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aef3c1b45c5418ead19f258774a301f83">FreeVmon</a> ()</td></tr>
<tr class="memdesc:aef3c1b45c5418ead19f258774a301f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free up the memory used to store Vmon3. <br /></td></tr>
<tr class="separator:aef3c1b45c5418ead19f258774a301f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948748d946c4186bce3252a6be2076df"><td class="memItemLeft" align="right" valign="top"><a id="a948748d946c4186bce3252a6be2076df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a948748d946c4186bce3252a6be2076df">GetRadialWF</a> (index_t index, std::vector&lt; double &gt; &amp;R, std::vector&lt; double &gt; &amp;PSI)</td></tr>
<tr class="memdesc:a948748d946c4186bce3252a6be2076df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the radial wave function of an orbit in the HF basis. <br /></td></tr>
<tr class="separator:a948748d946c4186bce3252a6be2076df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29de897a332985f5b08bd0f08a466db3"><td class="memItemLeft" align="right" valign="top"><a id="a29de897a332985f5b08bd0f08a466db3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a29de897a332985f5b08bd0f08a466db3">GetRadialWF_r</a> (index_t index, double R)</td></tr>
<tr class="memdesc:a29de897a332985f5b08bd0f08a466db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the radial wave function of an orbit in the HF basis. <br /></td></tr>
<tr class="separator:a29de897a332985f5b08bd0f08a466db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb9fc68d98aedc4cf1aae52da237339"><td class="memItemLeft" align="right" valign="top"><a id="a3fb9fc68d98aedc4cf1aae52da237339"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreezeOccupations</b> ()</td></tr>
<tr class="separator:a3fb9fc68d98aedc4cf1aae52da237339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aa734d2b1df54ddba236f279269fcc"><td class="memItemLeft" align="right" valign="top"><a id="ab7aa734d2b1df54ddba236f279269fcc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UnFreezeOccupations</b> ()</td></tr>
<tr class="separator:ab7aa734d2b1df54ddba236f279269fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab863d5d020e15854d4d591ec0ce6a1a0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ab863d5d020e15854d4d591ec0ce6a1a0">Vmon3Hash</a> (uint64_t a, uint64_t b, uint64_t c, uint64_t d, uint64_t e, uint64_t f)</td></tr>
<tr class="separator:ab863d5d020e15854d4d591ec0ce6a1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af675589807ed0369ce3c9ef30d9d625b"><td class="memItemLeft" align="right" valign="top"><a id="af675589807ed0369ce3c9ef30d9d625b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#af675589807ed0369ce3c9ef30d9d625b">Vmon3UnHash</a> (uint64_t key, int &amp;a, int &amp;b, int &amp;c, int &amp;d, int &amp;e, int &amp;f)</td></tr>
<tr class="memdesc:af675589807ed0369ce3c9ef30d9d625b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a hashed key and extract the six orbit indices that went into it. <br /></td></tr>
<tr class="separator:af675589807ed0369ce3c9ef30d9d625b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aad1a5eeadedf9689bbfc2e3d71b60aee"><td class="memItemLeft" align="right" valign="top"><a id="aad1a5eeadedf9689bbfc2e3d71b60aee"></a>
<a class="el" href="classOperator.html">Operator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aad1a5eeadedf9689bbfc2e3d71b60aee">Hbare</a></td></tr>
<tr class="memdesc:aad1a5eeadedf9689bbfc2e3d71b60aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input bare Hamiltonian. <br /></td></tr>
<tr class="separator:aad1a5eeadedf9689bbfc2e3d71b60aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4a6814a338d7e4c17575ac74763f30"><td class="memItemLeft" align="right" valign="top"><a id="a5d4a6814a338d7e4c17575ac74763f30"></a>
<a class="el" href="classModelSpace.html">ModelSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a5d4a6814a338d7e4c17575ac74763f30">modelspace</a></td></tr>
<tr class="memdesc:a5d4a6814a338d7e4c17575ac74763f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Model Space of the Hamiltonian. <br /></td></tr>
<tr class="separator:a5d4a6814a338d7e4c17575ac74763f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c73247cdb9255cebabaacc99ec55086"><td class="memItemLeft" align="right" valign="top"><a id="a9c73247cdb9255cebabaacc99ec55086"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a9c73247cdb9255cebabaacc99ec55086">C</a></td></tr>
<tr class="memdesc:a9c73247cdb9255cebabaacc99ec55086"><td class="mdescLeft">&#160;</td><td class="mdescRight">transformation coefficients, 1st index is ho basis, 2nd = HF basis <br /></td></tr>
<tr class="separator:a9c73247cdb9255cebabaacc99ec55086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc0aa9f25640979d5188443a19aeea5"><td class="memItemLeft" align="right" valign="top"><a id="a6fc0aa9f25640979d5188443a19aeea5"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a6fc0aa9f25640979d5188443a19aeea5">rho</a></td></tr>
<tr class="memdesc:a6fc0aa9f25640979d5188443a19aeea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">density matrix rho_ij <br /></td></tr>
<tr class="separator:a6fc0aa9f25640979d5188443a19aeea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30fe3bd6fa480cc21b85a830013c9fe"><td class="memItemLeft" align="right" valign="top"><a id="aa30fe3bd6fa480cc21b85a830013c9fe"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aa30fe3bd6fa480cc21b85a830013c9fe">KE</a></td></tr>
<tr class="memdesc:aa30fe3bd6fa480cc21b85a830013c9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">kinetic energy <br /></td></tr>
<tr class="separator:aa30fe3bd6fa480cc21b85a830013c9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae823da58505b21231d092b3ef7cec3bf"><td class="memItemLeft" align="right" valign="top"><a id="ae823da58505b21231d092b3ef7cec3bf"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ae823da58505b21231d092b3ef7cec3bf">Vij</a></td></tr>
<tr class="memdesc:ae823da58505b21231d092b3ef7cec3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 body piece of 2 body potential <br /></td></tr>
<tr class="separator:ae823da58505b21231d092b3ef7cec3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a0f38a655064375765f74182ce9334"><td class="memItemLeft" align="right" valign="top"><a id="a25a0f38a655064375765f74182ce9334"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a25a0f38a655064375765f74182ce9334">V3ij</a></td></tr>
<tr class="memdesc:a25a0f38a655064375765f74182ce9334"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 body piece of 3 body potential <br /></td></tr>
<tr class="separator:a25a0f38a655064375765f74182ce9334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45136295f4834a9f692f262eee75672a"><td class="memItemLeft" align="right" valign="top"><a id="a45136295f4834a9f692f262eee75672a"></a>
arma::mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a45136295f4834a9f692f262eee75672a">F</a></td></tr>
<tr class="memdesc:a45136295f4834a9f692f262eee75672a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fock matrix. <br /></td></tr>
<tr class="separator:a45136295f4834a9f692f262eee75672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa007e1dc1d1fc8f4a24b42fc82ff277b"><td class="memItemLeft" align="right" valign="top"><a id="aa007e1dc1d1fc8f4a24b42fc82ff277b"></a>
std::array&lt; std::array&lt; arma::mat, 2 &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#aa007e1dc1d1fc8f4a24b42fc82ff277b">Vmon</a></td></tr>
<tr class="memdesc:aa007e1dc1d1fc8f4a24b42fc82ff277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monopole 2-body interaction. <br /></td></tr>
<tr class="separator:aa007e1dc1d1fc8f4a24b42fc82ff277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddc7c175c587f4cbf8a64b36c07e57d"><td class="memItemLeft" align="right" valign="top"><a id="a5ddc7c175c587f4cbf8a64b36c07e57d"></a>
std::array&lt; std::array&lt; arma::mat, 2 &gt;, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a5ddc7c175c587f4cbf8a64b36c07e57d">Vmon_exch</a></td></tr>
<tr class="memdesc:a5ddc7c175c587f4cbf8a64b36c07e57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monopole 2-body interaction. <br /></td></tr>
<tr class="separator:a5ddc7c175c587f4cbf8a64b36c07e57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9700861effb1cb3739240b76ed519141"><td class="memItemLeft" align="right" valign="top"><a id="a9700861effb1cb3739240b76ed519141"></a>
arma::uvec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a9700861effb1cb3739240b76ed519141">holeorbs</a></td></tr>
<tr class="memdesc:a9700861effb1cb3739240b76ed519141"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of hole orbits for generating density matrix <br /></td></tr>
<tr class="separator:a9700861effb1cb3739240b76ed519141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c11fc0a59ceaeeb415a0e6c8d85e604"><td class="memItemLeft" align="right" valign="top"><a id="a0c11fc0a59ceaeeb415a0e6c8d85e604"></a>
arma::rowvec&#160;</td><td class="memItemRight" valign="bottom"><b>hole_occ</b></td></tr>
<tr class="separator:a0c11fc0a59ceaeeb415a0e6c8d85e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415fc1fbbba3a6a84d47e31ed18323c9"><td class="memItemLeft" align="right" valign="top">arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a415fc1fbbba3a6a84d47e31ed18323c9">energies</a></td></tr>
<tr class="memdesc:a415fc1fbbba3a6a84d47e31ed18323c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">occupations of hole orbits  <a href="#a415fc1fbbba3a6a84d47e31ed18323c9">More...</a><br /></td></tr>
<tr class="separator:a415fc1fbbba3a6a84d47e31ed18323c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2a195ad044947a9e1fb9f3a937d8a"><td class="memItemLeft" align="right" valign="top"><a id="a43e2a195ad044947a9e1fb9f3a937d8a"></a>
arma::vec&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a43e2a195ad044947a9e1fb9f3a937d8a">prev_energies</a></td></tr>
<tr class="memdesc:a43e2a195ad044947a9e1fb9f3a937d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPE's from last iteration. <br /></td></tr>
<tr class="separator:a43e2a195ad044947a9e1fb9f3a937d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c754579ad1a45f053a5305e87d4700"><td class="memItemLeft" align="right" valign="top"><a id="a22c754579ad1a45f053a5305e87d4700"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a22c754579ad1a45f053a5305e87d4700">tolerance</a></td></tr>
<tr class="memdesc:a22c754579ad1a45f053a5305e87d4700"><td class="mdescLeft">&#160;</td><td class="mdescRight">tolerance for convergence <br /></td></tr>
<tr class="separator:a22c754579ad1a45f053a5305e87d4700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c9e1791919c2ceef5584bdc9b84a81"><td class="memItemLeft" align="right" valign="top"><a id="a16c9e1791919c2ceef5584bdc9b84a81"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a16c9e1791919c2ceef5584bdc9b84a81">EHF</a></td></tr>
<tr class="memdesc:a16c9e1791919c2ceef5584bdc9b84a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hartree-Fock energy (Normal-ordered 0-body term) <br /></td></tr>
<tr class="separator:a16c9e1791919c2ceef5584bdc9b84a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94913a966701c27fde108b98e89b41"><td class="memItemLeft" align="right" valign="top"><a id="a0f94913a966701c27fde108b98e89b41"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a0f94913a966701c27fde108b98e89b41">e1hf</a></td></tr>
<tr class="memdesc:a0f94913a966701c27fde108b98e89b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-body contribution to EHF. <br /></td></tr>
<tr class="separator:a0f94913a966701c27fde108b98e89b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cddead4c300ca5c3505f04e1a630bc"><td class="memItemLeft" align="right" valign="top"><a id="a29cddead4c300ca5c3505f04e1a630bc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a29cddead4c300ca5c3505f04e1a630bc">e2hf</a></td></tr>
<tr class="memdesc:a29cddead4c300ca5c3505f04e1a630bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-body contribution to EHF. <br /></td></tr>
<tr class="separator:a29cddead4c300ca5c3505f04e1a630bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a37a2413483b1b484554c4a4f6755e"><td class="memItemLeft" align="right" valign="top"><a id="a89a37a2413483b1b484554c4a4f6755e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a89a37a2413483b1b484554c4a4f6755e">e3hf</a></td></tr>
<tr class="memdesc:a89a37a2413483b1b484554c4a4f6755e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-body contribution to EHF. <br /></td></tr>
<tr class="separator:a89a37a2413483b1b484554c4a4f6755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"><td class="memItemLeft" align="right" valign="top"><a id="a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3">iterations</a></td></tr>
<tr class="memdesc:a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterations used in <a class="el" href="classHartreeFock.html#a0666507747c17845ab4f74b97414703c" title="Diagonalize and UpdateF until convergence. ">Solve()</a> <br /></td></tr>
<tr class="separator:a7658fa0b1b05dfa7bf7b8aa7e5fd6bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4104112ce3a60a8fb86305df98d2e9"><td class="memItemLeft" align="right" valign="top"><a id="aac4104112ce3a60a8fb86305df98d2e9"></a>
std::vector&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon3_keys</b></td></tr>
<tr class="separator:aac4104112ce3a60a8fb86305df98d2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ca83cf6ad8949daffd11ba8f2c03fd"><td class="memItemLeft" align="right" valign="top"><a id="ad7ca83cf6ad8949daffd11ba8f2c03fd"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vmon3</b></td></tr>
<tr class="separator:ad7ca83cf6ad8949daffd11ba8f2c03fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0435b3f1485ddd1d8d91bbd84e008445"><td class="memItemLeft" align="right" valign="top"><a id="a0435b3f1485ddd1d8d91bbd84e008445"></a>
<a class="el" href="classIMSRGProfiler.html">IMSRGProfiler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a0435b3f1485ddd1d8d91bbd84e008445">profiler</a></td></tr>
<tr class="memdesc:a0435b3f1485ddd1d8d91bbd84e008445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiler for timing, etc. <br /></td></tr>
<tr class="separator:a0435b3f1485ddd1d8d91bbd84e008445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d87e7ce2ad6e56d12063a62ff91bf9"><td class="memItemLeft" align="right" valign="top"><a id="a42d87e7ce2ad6e56d12063a62ff91bf9"></a>
std::deque&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#a42d87e7ce2ad6e56d12063a62ff91bf9">convergence_ediff</a></td></tr>
<tr class="memdesc:a42d87e7ce2ad6e56d12063a62ff91bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save last few convergence checks for diagnostics. <br /></td></tr>
<tr class="separator:a42d87e7ce2ad6e56d12063a62ff91bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1366b8f034fb0feb9aed43480398f54"><td class="memItemLeft" align="right" valign="top"><a id="ac1366b8f034fb0feb9aed43480398f54"></a>
std::deque&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHartreeFock.html#ac1366b8f034fb0feb9aed43480398f54">convergence_EHF</a></td></tr>
<tr class="memdesc:ac1366b8f034fb0feb9aed43480398f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save last few convergence checks for diagnostics. <br /></td></tr>
<tr class="separator:ac1366b8f034fb0feb9aed43480398f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dba3b4a2fd164c68daeb7a744ede3c6"><td class="memItemLeft" align="right" valign="top"><a id="a5dba3b4a2fd164c68daeb7a744ede3c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>freeze_occupations</b></td></tr>
<tr class="separator:a5dba3b4a2fd164c68daeb7a744ede3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3d6bac9b4403e4bc599a89ad0c9b6056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6bac9b4403e4bc599a89ad0c9b6056">&#9670;&nbsp;</a></span>BuildMonopoleV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::BuildMonopoleV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only the monopole part of V is needed, so construct it. </p>
<p>Construct an unnormalized two-body monopole interaction </p><p class="formulaDsp">
\[ \langle ab | \bar{V}^{(2)} | cd \rangle = \sqrt{(1+\delta_{ab})(1+\delta_{cd})} \sum_{J} (2J+1) \langle ab | V^{(2)} | cd \rangle_{J} \]
</p>
<p> This method utilizes the operator method <a class="el" href="classTwoBodyME.html#a41e1d7a520f31b57283b7817a35bceb7">TwoBodyME::GetTBMEmonopole()</a> </p>

</div>
</div>
<a id="a1c146af25a09f427cc626d877ec6e518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c146af25a09f427cc626d877ec6e518">&#9670;&nbsp;</a></span>BuildMonopoleV3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::BuildMonopoleV3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only the monopole part of V3 is needed. </p>
<p>Construct an unnormalized three-body monopole interaction </p><p class="formulaDsp">
\[ \langle iab | \bar{V}^{(3)} | jcd \rangle = \sum\limits_{J,J_{12}}\sum_{Tt_{12}}(2J+1)(2T+1) \langle (ia)J_{12}t_{12};b JT| V^{(3)} | (jc)J_{12}t_{12}; d JT\rangle \]
</p>
 
</div>
</div>
<a id="aef506c5c5bc0f317ceb9c71bdc44d62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef506c5c5bc0f317ceb9c71bdc44d62b">&#9670;&nbsp;</a></span>CalcEHF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::CalcEHF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the Hartree Fock energy. </p>
<p>Calculate the HF energy. </p><p class="formulaDsp">
\begin{eqnarray*} E_{HF} &amp;=&amp; \sum_{\alpha} t_{\alpha\alpha} + \frac{1}{2}\sum_{\alpha\beta} V_{\alpha\beta\alpha\beta} + \frac{1}{6}\sum_{\alpha\beta\gamma} V_{\alpha\beta\gamma\alpha\beta\gamma} \\ &amp;=&amp; \sum_{ij} (2j_i+1) \rho_{ij} ( t_{ij} +\frac{1}{2}\tilde{V}^{(2)}_{ij} + \frac{1}{6}\tilde{V}^{(3)}_{ij} ) \end{eqnarray*}
</p>
<p> Where the matrices </p><p class="formulaDsp">
\begin{eqnarray*} \tilde{V}^{(2)}_{ij} &amp;=&amp; \sum_{ab} \rho_{ab}\bar{V}^{(2)}_{iajb} \\ \tilde{V}^{(3)}_{ij} &amp;=&amp; \sum_{abcd} \rho_{ab}\rho_{cd} \bar{V}^{(3)}_{iacjbd} \\ \end{eqnarray*}
</p>
<p> have already been calculated by <a class="el" href="classHartreeFock.html#a84fe0eb16f6e5835c920bf8fa98c4442" title="Update the Fock matrix with the new transformation coefficients C. ">UpdateF()</a>. </p>

</div>
</div>
<a id="a35ab9c4f96e68b1c9acea1d1407ecc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ab9c4f96e68b1c9acea1d1407ecc60">&#9670;&nbsp;</a></span>CheckConvergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HartreeFock::CheckConvergence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the current energies with those from the previous iteration. </p>
<p>Check for convergence using difference in s.p. energies between iterations. Converged when </p><p class="formulaDsp">
\[ \delta_{e} \equiv \sqrt{ \sum_{i}(e_{i}^{(n)}-e_{i}^{(n-1)})^2} &lt; \textrm{tolerance} \]
</p>
<p> where \( e_{i}^{(n)} \) is the \( i \)th eigenvalue of the Fock matrix after \( n \) iterations. </p>

</div>
</div>
<a id="a00f7b0c4cb7373a3f1a69ca27a4dfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f7b0c4cb7373a3f1a69ca27a4dfaed">&#9670;&nbsp;</a></span>Diagonalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::Diagonalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagonalize the Fock matrix. </p>
<p>[See Suhonen eq. 4.85] Diagonalize the fock matrix \( &lt;a|F|b&gt; \) and put the eigenvectors in \(C(i,\alpha) = &lt;i|\alpha&gt; \) and eigenvalues in the vector energies. Save the last vector of energies to check for convergence. Submatrices corresponding to different channels are diagonalized independently. This guarantees that J,Tz, and \( \pi \) remain good. </p>

</div>
</div>
<a id="a74c842cbf4e8caec72591c1205794f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c842cbf4e8caec72591c1205794f1f">&#9670;&nbsp;</a></span>FillLowestOrbits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::FillLowestOrbits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get new occupations based on the current single-particle energies. </p>
<p>Get new occupation numbers by filling the orbits in order of their single-particle energies. The last proton/neutron orbit can have a fractional filling, corresponding to ensemble normal ordering. </p>

</div>
</div>
<a id="a17bdb52033e2f62bba72ea86bc196b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bdb52033e2f62bba72ea86bc196b37">&#9670;&nbsp;</a></span>GetNormalOrderedH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOperator.html">Operator</a> HartreeFock::GetNormalOrderedH </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the Hamiltonian in the HF basis at the normal-ordered 2body level. </p>
<p>Returns the normal-ordered Hamiltonian in the Hartree-Fock basis, neglecting the residual 3-body piece. </p><p class="formulaDsp">
\[ E_0 = E_{HF} \]
</p>
 <p class="formulaDsp">
\[ f = C^{\dagger} F C \]
</p>
 <p class="formulaDsp">
\[ \Gamma = D^{\dagger} \left(V^{(2)}+V^{(3\rightarrow 2)} \right) D \]
</p>
 <p class="formulaDsp">
\[ V^{(2\rightarrow 3)J}_{ijkl} \equiv \frac{1}{\sqrt{(1+\delta_{ij})(1+\delta_{kl})}}\sum_{ab}\sum_{J_3}(2J_{3}+1)\rho_{ab}V^{JJJ_{3}}_{ijaklb} \]
</p>
<p> Where \( F\) is the Fock matrix obtained in <a class="el" href="classHartreeFock.html#a84fe0eb16f6e5835c920bf8fa98c4442" title="Update the Fock matrix with the new transformation coefficients C. ">UpdateF()</a> and the matrix \( D\) is the same as the one defined in <a class="el" href="classHartreeFock.html#a55914915cea16669e549025c244b62d0" title="Transform an operator from oscillator basis to HF basis. ">TransformToHFBasis()</a>. </p>

</div>
</div>
<a id="a53011b381945ed5c61f50b209db5bf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53011b381945ed5c61f50b209db5bf64">&#9670;&nbsp;</a></span>GetOmega()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOperator.html">Operator</a> HartreeFock::GetOmega </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a generator of the Hartree Fock transformation. </p>
<p>Get the one-body generator corresponding to the transformation to the HF basis. Since the unitary transformation for HF is given by the \( U_{HF} = C^{\dagger} \) matrix, we have \( e^{-\Omega} = C \Rightarrow \Omega = -\log(C) \). The log is evaluated by diagonalizing the one-body submatrix and taking the log of the diagonal entries. This is much slower than the other methods, but it might be useful. </p>

</div>
</div>
<a id="a2c3bdda2ea86f9a3b18d203c9aecc353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3bdda2ea86f9a3b18d203c9aecc353">&#9670;&nbsp;</a></span>PrintEHF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::PrintEHF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out the Hartree Fock energy. </p>
<p>Print out the Hartree Fock energy, and the 1-, 2-, and 3-body contributions to it. </p>

</div>
</div>
<a id="ab96b85eca26bf7c57430242201066932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96b85eca26bf7c57430242201066932">&#9670;&nbsp;</a></span>PrintSPE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::PrintSPE </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter function for Hbare. </p>
<p>Print out the single-particle energies </p>

</div>
</div>
<a id="a2eb6754f57250a03a2e1bd3e2aef4daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb6754f57250a03a2e1bd3e2aef4daf">&#9670;&nbsp;</a></span>ReorderCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::ReorderCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder the coefficients in C to eliminate phases etc. </p>
<p>Eigenvectors/values come out of the diagonalization energy-ordered. We want them ordered corresponding to the input ordering, i.e. we want the l,j,tz sub-blockes of the matrix C to be energy-ordered and positive along the diagonal. For a 3x3 matrix this would be something like (this needs to be updated) </p><p class="formulaDsp">
\[ \left( \begin{array}{rrr} -0.8 &amp; 0.2 &amp; -0.6 \\ -0.3 &amp; 0.3 &amp; 0.9 \\ 0.2 &amp; 0.9 &amp; -0.4 \\ \end{array}\right) \rightarrow \left(\begin{array}{rrr} 0.8 &amp; -0.6 &amp; 0.2 \\ 0.3 &amp; 0.9 &amp; 0.3 \\ -0.2 &amp; -0.4 &amp; 0.9 \\ \end{array}\right) \]
</p>
 
</div>
</div>
<a id="a0666507747c17845ab4f74b97414703c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0666507747c17845ab4f74b97414703c">&#9670;&nbsp;</a></span>Solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::Solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagonalize and UpdateF until convergence. </p>
<p>Diagonalize and update the Fock matrix until convergence. Then, call <a class="el" href="classHartreeFock.html#a2eb6754f57250a03a2e1bd3e2aef4daf" title="Reorder the coefficients in C to eliminate phases etc. ">ReorderCoefficients()</a> to make sure the index ordering and phases are preserved in the transformation from the original basis to the Hatree-Fock basis. </p>

</div>
</div>
<a id="a55914915cea16669e549025c244b62d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55914915cea16669e549025c244b62d0">&#9670;&nbsp;</a></span>TransformToHFBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOperator.html">Operator</a> HartreeFock::TransformToHFBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOperator.html">Operator</a> &amp;&#160;</td>
          <td class="paramname"><em>OpHO</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform an operator from oscillator basis to HF basis. </p>
<p>Takes in an operator expressed in the basis of the original Hamiltonian, and returns that operator in the Hartree-Fock basis. </p><p class="formulaDsp">
\[ t_{HF} = C^{\dagger} t_{HO} C \]
</p>
 <p class="formulaDsp">
\[ V_{HF}^{J} = D^{\dagger} V^{J}_{HO} D \]
</p>
<p> The matrix \( D \) is defined as </p><p class="formulaDsp">
\[ D_{ab\alpha\beta} \equiv \sqrt{ \frac{1+\delta_{ab}} {1+\delta_{\alpha\beta}} } C_{a\alpha} C_{b\beta} \]
</p>
<p> The factor in the square root is due to the fact that we're using normalized TBME's. Since only kets with \( a\leq b\) are stored, we can use the antisymmetry of the TBME's and define </p><p class="formulaDsp">
\[ D(J)_{ab\alpha\beta} \equiv \sqrt{ \frac{1+\delta_{ab}} {1+\delta_{\alpha\beta}} } \left( C_{a\alpha} C_{b\beta} -(1-\delta_{ab})(-1)^{j_a+j_b-J} C_{b\alpha}C_{a\beta}\right) \]
</p>
 
</div>
</div>
<a id="aad38c905e7e9f9e9757b5800e6910c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad38c905e7e9f9e9757b5800e6910c61">&#9670;&nbsp;</a></span>UpdateDensityMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::UpdateDensityMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the density matrix with the new coefficients C. </p>
<p>one-body density matrix \( &lt;i|\rho|j&gt; = \sum\limits_{\beta} n_{\beta} &lt;i|\beta&gt; &lt;\beta|j&gt; \) where \(n_{\beta} \) ensures that beta runs over HF orbits in the core (i.e. below the fermi surface) </p>

</div>
</div>
<a id="a84fe0eb16f6e5835c920bf8fa98c4442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fe0eb16f6e5835c920bf8fa98c4442">&#9670;&nbsp;</a></span>UpdateF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HartreeFock::UpdateF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the Fock matrix with the new transformation coefficients C. </p>
<p>[See Suhonen eq 4.85] </p><p class="formulaDsp">
\[ F_{ij} = t_{ij} + \frac{1}{2j_i+1}\sum_{ab} \rho_{ab} \bar{V}^{(2)}_{iajb} + \frac{1}{2(2j_i+1)}\sum_{abcd}\rho_{ab} \rho_{cd} \bar{V}^{(3)}_{iacjbd} \]
</p>
<ul>
<li>\( F \) is the Fock matrix, to be diagonalized</li>
<li>\( t \) is the kinetic energy</li>
<li>\(\rho\) is the density matrix defined in <a class="el" href="classHartreeFock.html#aad38c905e7e9f9e9757b5800e6910c61" title="Update the density matrix with the new coefficients C. ">UpdateDensityMatrix()</a></li>
<li>\( \bar{V}^{(2)} \) is the monopole component of the 2-body interaction defined in <a class="el" href="classHartreeFock.html#a3d6bac9b4403e4bc599a89ad0c9b6056" title="Only the monopole part of V is needed, so construct it. ">BuildMonopoleV()</a>.</li>
<li>\( \bar{V}^{(3)} \) is the monopole component of the 3-body interaction devined in <a class="el" href="classHartreeFock.html#a1c146af25a09f427cc626d877ec6e518" title="Only the monopole part of V3 is needed. ">BuildMonopoleV3()</a>. </li>
</ul>

</div>
</div>
<a id="ab863d5d020e15854d4d591ec0ce6a1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab863d5d020e15854d4d591ec0ce6a1a0">&#9670;&nbsp;</a></span>Vmon3Hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t HartreeFock::Vmon3Hash </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hashing function for rolling six orbit indices into a single long unsigned int. Each orbit gets 10 bits. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a415fc1fbbba3a6a84d47e31ed18323c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415fc1fbbba3a6a84d47e31ed18323c9">&#9670;&nbsp;</a></span>energies</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::vec HartreeFock::energies</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>occupations of hole orbits </p>
<p>vector of single particle energies </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="HartreeFock_8hh_source.html">HartreeFock.hh</a></li>
<li>HartreeFock.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 28 2021 20:53:31 for IM-SRG++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
